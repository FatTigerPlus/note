go并发编程的三大模型：

1. G（goroutine）：就是咱们常用的用go关键字创建的执行体，它对应一个结构体g，结构体里保存了goroutine的堆栈信息
2. M（machine）：表示操作系统的线程
3. P（processor）：表示处理器，有了它才能建立G、M的联系

<img src="http://akatsuke.com/image-20201021235746817.png" alt="image-20201021235746817" style="zoom:67%;" />

它的流程为：

​	首先是Process（P），它的作用类似于CPU的核，用于控制可以同时并发执行的任务数量，每个工作线程都必须绑定一个有效的P才能被允许执行任务，不然只能休眠，直到有空的P时被唤醒。P还为形成提供执行资源（对象分配内存，本地任务列表），线程独享所绑定的P资源，可以在无锁的状态性高效操作。

进程内的一切都在以goroutine（G）方式运行，包括运行时相关服务，以及main.main入口函数，G并非是执行体，它仅仅是保存并发任务状态，为任务执行提供所需栈内存空间。G任务创建后被放置在P本地队列或全局队列，等待工作线程调度执行。

实际的执行体是系统线程（M），它与P绑定，以调度循环方式不停执行G并发任务，M通过修改寄存器，将执行栈指向G自带的栈内存，并将此空间内分配堆栈帧，执行任务函数。当需要中途切换的时候只需将相关寄存器保存回G空间维持状态，任务M都可以根据这个数据恢复执行。线程只负责执行不再持有状态，这是并发任务跨线程调度实现多路复用的根本。

P/M构成执行组合体，但是P和M并非一一对应，通常，P的数量恒定，默认等于CPU 的数量，M由调度器按需创建，